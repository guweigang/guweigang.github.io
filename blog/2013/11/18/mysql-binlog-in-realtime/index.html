<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>mysql binlog in realtime - 闭眼听世界</title>
    <meta charset="utf-8" />
    <meta name="author" content="Gu Weigang" />
    <meta name="description" content="MySQL实时增量解析。" />
    <meta name="keywords" content="mysql, binlog, mysql replication" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">闭眼听世界</a></h1>
        <p>心如松静意无尘，气若浮萍了无痕！</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/guweigang">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="q" value="site:guweigang.com">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>mysql binlog in realtime</h1>
<p>
众所周知，MySQL是最受欢迎的互联网数据库（没有之一），它为开源而生。发展初期，很多公司都受益于其易用性和经济性。随着这些公司的成长，越来越多的公司投入到MySQL的开发中，因此MySQL的特性也越来越丰富，如：不同特性的存储引擎、Binlog主从复制方案等。
</p>

<p>
今天我们要探讨的就是如何实时解析MySQL Binlog，以及其所带来的巨大的业务价值。我可以在一瞬间说出很多应用场景，如：主从复制、缓存系统、检索引擎等。
</p>

<div class="center">

<div class="figure">
<p><img src="./binlog_app.png"  alt="binlog_app.png"/></p>
</div>
</div>

<p>
通常说来，在一个成熟的系统中我们有且仅有一份正确的全量数据（这里指MySQL中的数据）。而面对现在应用丰富的功能，MySQL并不能一直很好的满足我们。比如：我们需要使用缓存系统来加速服务，需要完备的检索系统来提供搜索服务，需要事件触发实时地发送通知等。但是摆在我们面前的问题是数据只有一份，且我们直接操作的都是MySQL，如何能让除MySQL之外的其他系统拥有同样的数据？且我们总是希望MySQL中的数据与其他系统的数据差异越小越好，越实时越好。当然我们可能会有一系列方案来解决这个问题，最典型的方法有两种：
</p>

<ul class="org-ul">
<li>双写， 当你在更新MySQL的同时更新缓存系统、更新检索引擎，触发事件发送通知。这么做的确能解决问题，但是因为都是异构系统，没有一种机制能够保证写入成功。也就是说随着时间的推移，数据差异会越来越大。不仅如此，如果外部系统很多，这么做还会影响到主业务逻辑的响应时间。
</li>

<li>定时任务，在主业务逻辑中耦合更新其他系统的代码是不OK的，外部系统只有几个还行，如果要更新100个外部系统，这时候当如何处理呢？通过定时任务异步地去做这件事情看上去是一个更好的方案。的确如此，但是任务执行频率是多少呢？每1分钟？每10分钟？当然我们可以根据业务需要制定这个频率，乍想一下没啥问题，不过再想一下，定时任务具体用来做什么，消费业务维护的一个队列，或是每条数据都会有一个updateTime（on update CURRENT_TIMESTAMP）字段，通过扫表方式查找出每条被修改的数据？

<ul class="org-ul">
<li>由业务端维护一个队列，就是说在业务端做操作的时候顺便把自己操作的内容写到队列里面去，然后由下游来消费这个队列。

<p>
这种方式由业务端来维护操作记录，好处是能保证数据的业务完整性，坏处是在业务端耦合了非业务相关的逻辑，每当数据操作时都需要开启事务保证业务操作和操作日志都正确地写入，如果以后因为某些原因要直接操作DB，这种情况就很危险了，在操作DB时无法模拟复杂的业务逻辑计算和关系。
</p>
</li>
</ul>
</li>
</ul>

<p>
如果你使用这种方法，很可能会写出下面这段代码：
</p>

<div class="org-src-container">

<pre class="src src-PHP">$db = getDI()-&gt;get("test_db");
$db-&gt;begin();
$db-&gt;update("// logic operate");
$db-&gt;insert("// operate logs");
$db-&gt;commit();
</pre>
</div>

<p>
而且很可能你设计的操作日志表会是这样子的：
</p>

<div class="center">
<!-- This HTML table template is generated by emacs 24.3.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;event_id&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;user_id&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;object_id&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;level&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;event_type&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;mcid&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;addtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;152&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;153&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;154&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;3007209739&nbsp;<br />
      &nbsp;3007209739&nbsp;<br />
      &nbsp;3007209739&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;200&nbsp;<br />
      &nbsp;&nbsp;&nbsp;202&nbsp;<br />
      &nbsp;&nbsp;&nbsp;201&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;2013-07-17&nbsp;04:06:05&nbsp;<br />
      &nbsp;0000-00-00&nbsp;00:00:00&nbsp;<br />
      &nbsp;0000-00-00&nbsp;00:00:00&nbsp;
    </td>
  </tr>
</table>
</div>

<ul class="org-ul">
<li>扫表找出变更的记录，使用下面的SQL扫出某个时间点之后所有变化过的记录。这种方式解放了业务端，以一种更解耦的方式来处理增量变更，非常适合无状态缓存更新之类的场景。当然如果表记录数过大可能会有慢查询。但如果是有状态变化的数据，这种方式会丢失更新之前的数据。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-SQL">SELECT * FROM `products` WHERE updateTime &gt; '2013-11-12 12:00:00' ORDER BY updateTime LIMIT 1000;
</pre>
</div>


<p>
下面我来介绍下，我们的应用场景，先看一张图：
</p>

<div class="center">

<div class="figure">
<p><img src="./app_arch.png"  alt="app_arch.png"/></p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2013-11-18</span>
        <span title="last modification date" class="post-info">2013-11-21</span>
        <span title="tags" class="post-info"><a href="/tags/mysql/">mysql</a>, <a href="/tags/php-binlog/">php-binlog</a></span>
        <span title="author" class="post-info">Gu Weigang</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2013/11/18/mysql-binlog-in-realtime/";
          var disqus_url = "http://guweigang.com/blog/2013/11/18/mysql-binlog-in-realtime/";
          var disqus_shortname = 'guweigang';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'cnwggu@gmail.com']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.0.3)</p>
        <p>
          Copyright &copy; 2012 - 2013 <a href="mailto:guweigang &lt;at&gt; outlook &lt;dot&gt; com">Gu Weigang</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
        </p>
      </div>
    </div>
  </body>
</html>
