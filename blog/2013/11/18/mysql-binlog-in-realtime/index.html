<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>mysql binlog in realtime - 闭眼听世界</title>
    <meta charset="utf-8" />
    <meta name="author" content="Gu Weigang" />
    <meta name="description" content="MySQL实时增量解析" />
    <meta name="keywords" content="mysql, binlog, mysql replication" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">闭眼听世界</a></h1>
        <p>心如松静意无尘，气若浮萍了无痕！</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/guweigang">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="q" value="site:guweigang.com">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>mysql binlog in realtime</h1>
<p>
众所周知，MySQL是最受欢迎的互联网数据库（没有之一）———————为开源而生。发展初期，很多公司都受益于其易用性和经济性。随着这些公司的成长，越来越多的公司投入到MySQL的开发中，因此MySQL的特性也越来越丰富，如：不同特性的存储引擎、Binlog主从复制方案等。
</p>

<p>
今天我们要探讨的就是如何实时解析MySQL Binlog，以及其所带来的巨大的业务价值。我可以在一瞬间说出很多应用场景，如：主从复制、缓存系统、检索引擎等。如下图所示，MySQL的Binlog不仅仅能用于MySQL服务之间的主从复制，还能造福其他非MySQL服务：
</p>

<div class="center">

<div class="figure">
<p><img src="./binlog_app.png"  alt="binlog_app.png"/></p>
</div>
</div>

<p>
在一个成熟的商业系统中我们有且仅有一份正确的全量数据（这里指MySQL中的数据）。而面对现在应用丰富的功能以及用户越来越高的要求，MySQL并不能一直很好的满足我们。比如：我们需要使用缓存系统来加速服务，需要完备的检索系统来提供搜索服务，需要事件触发实时地发送通知等。但是摆在我们面前的问题是只有一份数据，且我们直接操作的都是MySQL（本文用MySQL来代表所有数据库系统），如何能让除MySQL之外的其他系统拥有同样的数据？且我们总是希望MySQL中的数据与其他系统的数据差异越小越好，越实时越好。当然我们可能会有一系列方案来解决这个问题，最典型的方法有两种：
</p>

<ul class="org-ul">
<li>双写， 当你在更新MySQL的同时更新缓存系统、更新检索引擎，触发事件发送通知。这么做的确能解决问题，但是因为都是异构系统，没有一种机制能够保证写入成功。也就是说随着时间的推移，数据差异会越来越大。不仅如此，如果外部系统很多，这么做还会影响到主业务逻辑的响应时间。
</li>
</ul>


<ul class="org-ul">
<li>定时任务，在主业务逻辑中耦合更新其他系统的代码是不OK的，外部系统只有几个还行，如果要更新100个外部系统，这时候当如何处理呢？通过定时任务异步地去做这件事情看上去是一个更好的方案。的确如此，但是任务执行频率是多少呢？每1分钟？每10分钟？当然我们可以根据业务需要制定这个频率，乍想一下没啥问题，不过再想一下，定时任务具体用来做什么，消费业务维护的一个队列，或是每条数据都会有一个updateTime（on update CURRENT_TIMESTAMP）字段，通过扫表方式查找出每条被修改的数据？

<ul class="org-ul">
<li>定时导出全量：在数据量比较少的时候这是最省事儿的方法，当然下游每次必须清空自己的数据重新全量导入，数据量稍大一点代价就特别大。
</li>

<li>业务系统维护一个队列（在业务库中新建表当作队列）：在业务系统中操作数据的时候顺便把自己操作的日志写到队列里面，然后由下游来消费这个队列。

<p>
这种方式由业务系统来维护操作记录，好处是能保证数据的业务完整性，坏处是在业务端耦合了非业务相关的逻辑，每当数据有变更时都需要开启事务保证业务操作和其操作日志都能正确地写入。如果以后因为某些原因要直接操作DB，这种情况就很危险了，在操作DB时无法模拟复杂的业务逻辑计算和关系。
</p>
</li>

<li>定时扫表找出变更记录：这种方法使业务端远离水火，以一种更解耦的方式来处理增量，非常适合无状态缓存更新之类的场景，当然如果表记录数过大可能会有慢查询。但如果存在状态流转的的数据，这种方式会丢失状态流转方向。
</li>
</ul>
</li>
</ul>


<p>
如果你使用队列方式，很可能会写出下面这段代码：
</p>

<div class="org-src-container">

<pre class="src src-PHP">$db = getDI()-&gt;get("test_db");
$db-&gt;begin();
$db-&gt;update("// logic operate");
$db-&gt;insert("// operate logs");
$db-&gt;commit();
</pre>
</div>

<p>
而且很可能你设计的操作日志表看起来会是这样子的：
</p>

<div class="center">
<!-- This HTML table template is generated by emacs 24.3.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;event_id&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;user_id&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;object_id&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;level&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;event_type&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;mcid&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;addtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;152&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;153&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;154&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;3007209739&nbsp;<br />
      &nbsp;3007209739&nbsp;<br />
      &nbsp;3007209739&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;200&nbsp;<br />
      &nbsp;&nbsp;&nbsp;202&nbsp;<br />
      &nbsp;&nbsp;&nbsp;201&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;2013-07-17&nbsp;04:06:05&nbsp;<br />
      &nbsp;0000-00-00&nbsp;00:00:00&nbsp;<br />
      &nbsp;0000-00-00&nbsp;00:00:00&nbsp;
    </td>
  </tr>
</table>
</div>

<p>
如果你扫表的话可能会写出下面这段SQL：
</p>

<div class="org-src-container">

<pre class="src src-SQL">SELECT * FROM `products` WHERE updateTime &gt; '2013-11-12 12:00:00' ORDER BY updateTime LIMIT 1000;
</pre>
</div>

<p>
下面我来具体介绍下我们的应用场景，以及我们是如何利用MySQL Binlog解决这个问题的，先上图：
</p>

<div class="center">

<div class="figure">
<p><img src="./app_arch.png"  alt="app_arch.png"/></p>
</div>
</div>

<p>
这是我们整个系统的架构图，左边可以看成用户系统，右边则是商业系统。浏览器向前端搜索服务集群（图中红色部份）发送请求后，前端集群会把用户的请求数据发往很多个后端服务，而不同的后端之间并不是同构的，所以基本上都会有一个“长连接/协议转换代理层”（图中红色部份），然后再由后端决定是否满足用户需求，最后再由前端集群拼接来自不同后端服务的结果并呈现给网民。
</p>

<p>
看似一个海量访问的服务，其实是由无数个小服务组成的，图中所示就是我们组做的小服务，在具体场景中蓝色部分做的事情是把前端服务集群的协议转换成FASTCGI协议，并转发给后端服务UI/PHP-FPM。虽然名称叫UI，但是做的不是我们所理解的UI的工作，而是对于后面的检索和数据流来说它是最前面的一部分，所以才叫UI。它承担的工作是解析代理层发来的数据，并根据请求数据和参数构造结构化的查询条件，当然这个构造的过程可能仍需要请求很多外部服务，然后向检索系统（BS）发出请求，BS返回的是一个实体ID集合（你可以理解为商品ID），UI根据实体ID到数据库（这里省略了缓存系统）里面查询实体详情，整个完程就是这样。
</p>

<p>
我们这个架构中也存在上面描述的异构系统，BS（Basic Search）模块是对Lucene的二次开发，它需要DB中的数据来建立索引，而客户会时不时地往DB里面写一些数据，为了能让UI实时地从BS中检索到新数据，DB的所有变更要能实时地体现到BS中，这是用双写／定时任务无法完成的。所以我们开发了基于MySQL Binlog的异步事件框架(AdPipe)。
</p>

<p>
AdPipe由以下几部分组成：
</p>

<ul class="org-ul">
<li>BIZ framework: 大家都知道PHP是最快的，所以经常需要变更的事件逻辑使用PHP写。
</li>
<li>PHP ext: 为了能在PHP用户空间写Binlog事件逻辑，不可避免地需要PHP扩展。
</li>
<li>Binlog listener: 与MySQL Server连接，实现Binlog议协。
</li>
</ul>


<p>
来看看BIZ框架的代码：
</p>

<p>
首先是启动脚本
</p>

<script src="https://gist.github.com/guweigang/7637250.js"></script>

<p>
上面代码主要职责是连接MySQL Server，并且设置Binlog的位置，建立连接后根据接收到的事件调用BinlogEvent相应的方法。
</p>

<p>
其次是事件处理类，BinlogEvent：
</p>

<script src="https://gist.github.com/guweigang/7637601.js"></script>

<p>
最后是消息打包类，Message
</p>

<script src="https://gist.github.com/guweigang/7637720.js"></script>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2013-11-18</span>
        <span title="last modification date" class="post-info">2013-11-25</span>
        <span title="tags" class="post-info"><a href="/tags/mysql/">mysql</a>, <a href="/tags/php-binlog/">php-binlog</a></span>
        <span title="author" class="post-info">Gu Weigang</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2013/11/18/mysql-binlog-in-realtime/";
          var disqus_url = "http://guweigang.com/blog/2013/11/18/mysql-binlog-in-realtime/";
          var disqus_shortname = 'guweigang';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'cnwggu@gmail.com']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.0.3)</p>
        <p>
          Copyright &copy; 2012 - 2013 <a href="mailto:guweigang &lt;at&gt; outlook &lt;dot&gt; com">Gu Weigang</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
        </p>
      </div>
    </div>
  </body>
</html>
