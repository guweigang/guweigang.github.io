#+TITLE:       Malloc in C
#+AUTHOR:      Gu Weigang
#+EMAIL:       guweigang@outlook.com
#+DATE:        2013-12-03 Tue
#+URI:         /blog/%y/%m/%d/malloc/
#+KEYWORDS:    c, malloc
#+TAGS:        c
#+LANGUAGE:    zh_CN
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

#+BEGIN_HTML
<style type="text/css">
pre.src-C {
    background-color: black !important;
    font-weight: bolder !important;
}

b:before, b:after, strong:before, strong:after {
    content: "";
}

i:before, i:after, em:before, em:after {
    content: "";
}
</style>
#+END_HTML


#+BEGIN_QUOTE

原文地址： http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Malloc1/lecture.html
原文作者： [[http://www.cs.utk.edu/~plank][Jim Plank]]
译文作者： [[http://guweigang.com][顾伟刚]]

#+END_QUOTE


#+BEGIN_CENTER

译者注：一直想找时间好好理一下C语言中malloc的使用方法及其原理，它是如此的重要以至于影响到程序的方方面面。现在终于有机会了，我将借助这个讲义来记录和分享malloc。

#+END_CENTER

#+BEGIN_QUOTE

在尝试使用本文提到的代码之前请先看讲义。不幸的是，实验室机器上的 *malloc()* 和  *free* 的实现百分之百和本讲义中的不一样。因为这些讲义是在20世纪90年代中期编写的，而 /malloc/ 的实现几乎每几年都要变化一次。

而我坚持使用本讲义来教学是因为它足够清晰。如果想知道它和现在机器实现的联系和区别，请猛击 http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Malloc1/diff.html。

#+END_QUOTE

------

这是一篇关于 *sbrk()* 和 *malloc()* 的讲义。

上一节课我们学习了操作系统内存的通用知识 -- 我们了解到代码段的尾地址是 *&etext* ，全局段的尾地址是 *&edata* 。随着程序的运行，堆内存会不断地增长，因为代码使用 *malloc()* 从堆中分配内存。为了解决堆内存局限的问题，我们必须使用 *brk()* 和 *sbrk()* 。它们都是系统调用，我们可以通过UNIX的man手册了解它们。这里我们仅讨论 *sbrk()* ，因为你只需要跟它打交道就行了。

#+BEGIN_SRC C
caddr_t sbrk(int incr);
#+END_SRC

*caddr_t* 是一个“C地址指针”。它等同于 *(char *)* 或者 *(void *)* 。

这个操作指定操作系统给当前堆多分配 *incr* 字节内存。它返回调用 *sbrk()* 之前的堆内存尾地址。因此，调用 *sbrk()* 之后堆内存新的尾地址是：

#+BEGIN_SRC C
sbrk(incr) + incr;
#+END_SRC

如果你调用 *sbrk(0)* ，它会返回当前堆内存的尾地址给你。

现在， *malloc()* （ 包括相应的 *realloc()* 和 *calloc()* ）都是通过调用 *sbrk()* 获取堆内存空间的。它们只是 *sbrk()* 的习惯用法。因此，可以说，获取堆内存的唯一方法是通过调用 *malloc()* 或 *sbrk()* 。但是你始终应该使用 *malloc()* ，因为它更高效。

------

让我们来试试，请看fb2.c：

#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

main()
{
  int *i1, *i2;

  printf("sbrk(0) before malloc(4): 0x%x\n", sbrk(0));
  i1 = (int *) malloc(4);
  printf("sbrk(0) after 'i1 = (int *) malloc(4)': 0x%x\n", sbrk(0));
  i2 = (int *) malloc(4);
  printf("sbrk(0) after 'i2 = (int *) malloc(4)': 0x%x\n", sbrk(0));
  printf("i1 = 0x%x, i2 = 0x%x\n", i1, i2);
}
#+END_SRC

这个示例打印出调用 *malloc()* 前后 *sbrk(0)* 的结果。下面是运行在 *hydra3a* 的结果：

#+BEGIN_EXAMPLE
UNIX> fb2
sbrk(0) before malloc(4): 0x21ab0
sbrk(0) after `i1 = (int *) malloc(4)': 0x23ab0
sbrk(0) after `i2 = (int *) malloc(4)': 0x23ab0
i1 = 0x21ac0, i2 = 0x21ad0
UNIX>
#+END_EXAMPLE

注意到， *sbrk()* 返回值在调用 *malloc()* 之后并没有发生变化。为什么会这样？因为 *malloc()* 会缓冲内存。当它调用 *sbrk()* 申请内存时，它会申请一块大内存 -- 如12K或8K，之后的 *malloc()* 会从缓冲区里面获取内存。换句话说，在分配完内存i1和i2之后，缓冲区中还剩一整块内存（从 0x0x21ad0 至 0x0x23ab0）供 *malloc()* 使用，在这之前它都无需再次调用 *sbrk()* ，在这个示例中缓冲区内大概还剩8160字节内存。因此，在示例 fb2a.c 中，当我们分配完i1和i2后，再申请大于8160字节（ *malloc()* ）的内存时，我们期待看到发生 *sbrk()* 的调用以获取更多内存。事实的确如此：

#+BEGIN_EXAMPLE

UNIX> fb2a
sbrk(0) before malloc(4): 0x21b68
sbrk(0) after `i1 = (int *) malloc(4)': 0x23b68
sbrk(0) after `i2 = (int *) malloc(4)': 0x23b68
i1 = 0x21b78, i2 = 0x21b88, sbrk(0)-i2 = 8160
sbrk(0) after `i3 = (int *) malloc(8164)': 0x25b68
i3 = 0x21f78
UNIX>

#+END_EXAMPLE

现在来看fb3.c, 调用 *malloc(4)* 10次，并且打印出分配的内存地址：

#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>

main()
{
  int j, *buf;

  for (j = 0; j < 10; j++) {
    buf = (int *) malloc(4);
    printf("malloc(4) returned 0x%x\n", buf);
  }
}
#+END_SRC

结果如下：

#+BEGIN_EXAMPLE
UNIX> fb3
malloc(4) returned 0x219d0
malloc(4) returned 0x219e0
malloc(4) returned 0x219f0
malloc(4) returned 0x21a00
malloc(4) returned 0x21a10
malloc(4) returned 0x21a20
malloc(4) returned 0x21a30
malloc(4) returned 0x21a40
malloc(4) returned 0x21a50
malloc(4) returned 0x21a60
UNIX>
#+END_EXAMPLE

观察上面的打印结果，你将会发现每次 *malloc()* 返回的地址相比之前一次调用都是是以 16 字节递增的。你可能会想为什么不是4字节呢，因为你只请求了4字节内存？这里发生了一些事情， *malloc()* 每次都会额外分配一些字节以帮助保存申请记录。这些额外的字节在你调用 *free()* 的时候将发挥重要的作用。这些额外的字节通常是在内存申请前分配的。这也是我们之后讨论 *free()* 的原因。

再看fb4.c，这个文件做的事情是：使用 *malloc()* 分配一整块内存，然后打印出他们的起始地址，以及这个起始地址之前的1个字和2个字（这里我使用“字”来代表4字节大小）。这是大部分程序员认为的“不安全”的代码，可是要弄清楚这些事情我们只能做了。你可以看到, *malloc()* 返回地址之前的2个字的空间存领了本次实际分配的内存大小。好像有点混乱了，我们来仔细看看 *fb4* 的输出：（不同的操作系统上， *malloc* 的工作方式不一样。如果你的输出跟我的不一样，请猛击 [[http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Malloc1/diff.html][这里]]）。

#+BEGIN_SRC C
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

main()
{
  int *buf;
  int i, sz;

  i = 1000;
  printf("sbrk(0) = 0x%x\n", sbrk(0));
  for (sz = 4; sz < 32; sz += 4) {
    buf = (int *) malloc(sz);
    buf[0] = i;
    i++;
  printf("Allocated %d bytes.  buf = 0x%x, buf[-1] = %d, buf[-2] = %d, buf[0] = %d\n", 
            sz, (unsigned int) buf, buf[-1], buf[-2], buf[0]);
  }

  sz = 100;
  buf = (int *) malloc(sz);
  buf[0] = i;
  i++;
  printf("Allocated %d bytes.  buf = 0x%x, buf[-1] = %d, buf[-2] = %d, buf[0] = %d\n", 
            sz, (unsigned int) buf, buf[-1], buf[-2], buf[0]);
  printf("sbrk(0) = 0x%x\n", sbrk(0));
}
#+END_SRC

其输出结果如下：

#+BEGIN_EXAMPLE
UNIX> fb4
sbrk(0) = 0x70f8
Allocated 4 bytes.  buf = 0x61a8, buf[-1] = 0, buf[-2] = 16, buf[0] = 1000
Allocated 8 bytes.  buf = 0x61b8, buf[-1] = 0, buf[-2] = 16, buf[0] = 1001
Allocated 12 bytes.  buf = 0x61c8, buf[-1] = 0, buf[-2] = 24, buf[0] = 1002
Allocated 16 bytes.  buf = 0x61e0, buf[-1] = 0, buf[-2] = 24, buf[0] = 1003
Allocated 20 bytes.  buf = 0x61f8, buf[-1] = 0, buf[-2] = 32, buf[0] = 1004
Allocated 24 bytes.  buf = 0x6218, buf[-1] = 0, buf[-2] = 32, buf[0] = 1005
Allocated 28 bytes.  buf = 0x6238, buf[-1] = 0, buf[-2] = 40, buf[0] = 1006
Allocated 100 bytes.  buf = 0x6260, buf[-1] = 0, buf[-2] = 112, buf[0] = 1007
sbrk(0) = 0x70f8
UNIX>
#+END_EXAMPLE

现在我们看一下调用 *malloc()* 之后堆的状况，注意，这里 *buf\[0\]* 的内容被设置为 *i* = 1000：

#+BEGIN_EXAMPLE

         |---------------|  
         |      ...      | 
         |               |      
         |      16       | 0x61a0
         |               | 0x61a4     
         |     1000      | 0x61a8  <--------- return value
         |               | 0x61ac
         |               | 0x61b0
         |               | 0x61b4
         |      ...      |      
         |               |      
         |               |      
         |               |      
         |---------------| 0x70f8 (sbrk(0));
                                            
#+END_EXAMPLE
