#+TITLE:       Malloc in C
#+AUTHOR:      Gu Weigang
#+EMAIL:       guweigang@outlook.com
#+DATE:        2013-12-03 Tue
#+URI:         /blog/%y/%m/%d/malloc/
#+KEYWORDS:    c, malloc
#+TAGS:        c
#+LANGUAGE:    zh_CN
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

#+BEGIN_HTML
<style type="text/css">
pre.src-C {
    background-color: black !important;
    font-weight: bolder !important;
}

b:before, b:after, strong:before, strong:after {
    content: "";
}

i:before, i:after, em:before, em:after {
    content: "";
}
</style>
#+END_HTML


#+BEGIN_QUOTE

原文地址： http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Malloc1/lecture.html
原文作者： [[http://www.cs.utk.edu/~plank][Jim Plank]]
译文作者： [[http://guweigang.com][顾伟刚]]

#+END_QUOTE


#+BEGIN_CENTER

译者注：一直想找时间好好理一下C语言中malloc的使用方法及其原理，它是如此的重要以至于影响到程序的方方面面。现在终于有机会了，我将借助这个讲义来记录和分享malloc。

#+END_CENTER

#+BEGIN_QUOTE

在尝试使用本文提到的代码之前请先看讲义。不幸的是，实验室机器上的 *malloc()* 和  *free* 的实现百分之百和本讲义中的不一样。因为这些讲义是在20世纪90年代中期编写的，而 /malloc/ 的实现几乎每几年都要变化一次。

而我坚持使用本讲义来教学是因为它足够清晰。如果想知道它和现在机器实现的联系和区别，请猛击 http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Malloc1/diff.html。

#+END_QUOTE

-----

这是一篇关于 *sbrk()* 和 *malloc()* 的讲义。

上一节课我们学习了操作系统内存的通用知识 -- 我们了解到代码段的尾地址是 *&etext* ，全局段的尾地址是 *&edata* 。随着程序的运行，堆内存会不断地增长，因为代码使用 *malloc()* 从堆中分配内存。为了解决堆内存局限的问题，我们必须使用 *brk()* 和 *sbrk()* 。它们都是系统调用，我们可以通过UNIX的man手册了解它们。这里我们仅讨论 *sbrk()* ，因为你只需要跟它打交道就行了。

#+BEGIN_SRC C
caddr_t sbrk(int incr);
#+END_SRC

*caddr_t* 是一个“C地址指针”。它等同于 *(char *)* 或者 *(void *)* 。

这个操作指定操作系统给堆内存多分配 *incr* 字节空间。它返回调用 *sbrk()* 之前的堆内存尾地址。因此，调用 *sbrk()* 之后堆内存新的尾地址是：

#+BEGIN_SRC C
sbrk(incr) + incr;
#+END_SRC

如果你调用 *sbrk(0)* ，它会返回当前堆内存的尾地址给你。

现在， *malloc()* （ 包括相应的 *realloc()* 和 *calloc()* ）都是通过调用 *sbrk()* 获取堆内存空间的。它们只是 *sbrk()* 的日常用法。因此，可以说，获取堆内存的唯一方法是通过调用 *malloc()* 或 *sbrk()* 。但是你始终应该使用 *malloc()* ，因为它更高效。

----

让我们来试试，请看fb2.c：

#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

main()
{
  int *i1, *i2;

  printf("sbrk(0) before malloc(4): 0x%x\n", sbrk(0));
  i1 = (int *) malloc(4);
  printf("sbrk(0) after `i1 = (int *) malloc(4)': 0x%x\n", sbrk(0));
  i2 = (int *) malloc(4);
  printf("sbrk(0) after `i2 = (int *) malloc(4)': 0x%x\n", sbrk(0));
  printf("i1 = 0x%x, i2 = 0x%x\n", i1, i2);
}
#+END_SRC
