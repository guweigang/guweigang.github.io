#+TITLE: 正则表达式之贪婪匹配和非贪婪匹配
#+AUTHOR: Gu Weigang
#+EMAIL: guweigang@outlook.com
#+DATE: 2011-04-30 Sat
#+URI: /blog/2011/04/30/the-greedy-regular-expression-matching-and-non-greedy-matching/
#+KEYWORDS: 
#+TAGS: dir, regex
#+LANGUAGE: zh_CN
#+OPTIONS: H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 

好吧，我透露下我最常用的正则手册地址吧，[[http://www.regexlab.com/zh/regref.htm][http://www.regexlab.com/zh/regref.htm]]。关于贪婪匹配和非贪婪匹配，今天群里面讨论得比较激烈。
*贪婪模式：*
在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如："{m,n}", "{m,}", "?", "*", "+"，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 "dxxxdxxxd"，举例如下：











表达式




匹配结果










[[http://www.regexlab.com/zh/workshop.asp?pat=%28d%29%28%5Cw%2B%29&txt=dxxxdxxxd][(d)(\w+)]]




"\w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"










[[http://www.regexlab.com/zh/workshop.asp?pat=%28d%29%28%5Cw%2B%29%28d%29&txt=dxxxdxxxd][(d)(\w+)(d)]]




"\w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "\w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"\w+" 可以 "让出" 它本来能够匹配的最后一个 "d"











由此可见，"\w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "*" 和 "{m,n}" 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这 种匹配原则就叫作 "贪婪" 模式 。

*非贪婪模式：*

在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：











表达式




匹配结果










[[http://www.regexlab.com/zh/workshop.asp?pat=%28d%29%28%5Cw%2B%3F%29&txt=dxxxdxxxd][(d)(\w+?)]]




"\w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："\w+?" 只匹配了一个 "x"










[[http://www.regexlab.com/zh/workshop.asp?pat=%28d%29%28%5Cw%2B%3F%29%28d%29&txt=dxxxdxxxd][(d)(\w+?)(d)]]




为了让整个表达式匹配成功，"\w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是："\w+?" 匹配 "xxx"











更多的情况，举例如下：

举例1：表达式 "<td>(.*)</td>" 与字符串 "<td><p>aa</p></td> <td><p>bb</p></td>" 匹配时，匹配的结果是：成功；匹配到的内容是 "<td><p>aa</p></td> <td><p>bb</p></td>" 整个字符串， 表达式中的 "</td>" 将与字符串中最后一个 "</td>" 匹配。

举例2：相比之下，表达式 "<td>(.*?)</td>" 匹配举例1中同样的字符串时，将只得到 "<td><p>aa</p></td>"， 再次匹配下一个时，可以得到第二个 "<td><p>bb</p></td>"。

看完这些还不了解的自拍三下。引出这个话题的是@老王子，他问下面这个正则是什么意思：


#+BEGIN_EXAMPLE
    preg_replace('/(.*?)[^\/]+\/$/', '$1', $current_dir_path);
#+END_EXAMPLE


很明显这里用了非贪婪匹配，这个正则的目的是为了获得给定目录$current\_dir\_path的上级目录，@老王子给出的代码中还有另一段：


#+BEGIN_EXAMPLE
    if(!preg_match('/\/$/', $current_path)) {
    echo "Parameter is not valid.";
    exit;
}
#+END_EXAMPLE


这段代码的目的是要检查$current\_path变量的最后一个字符是不是/。都写得相当巧妙，不过在我看来，上面的代码过度依赖正则表达式了。正则表达式虽然强大，但过度使用性能令人担忧，所以上面两个案例完全可以用PHP函数重写。


#+BEGIN_EXAMPLE
    // 1st get parent dir of $current_path
dirname($current_path);

// 2nd check the last char of $current_path
if ('/' !== strrchr($current_path, '/')) {
    echo "Parameter is not valid.";
    exit;
}
#+END_EXAMPLE



