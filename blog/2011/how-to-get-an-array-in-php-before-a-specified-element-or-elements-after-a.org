#+TITLE: PHP中如何获得数组中指定元素的前一个或后一个元素
#+AUTHOR: Gu Weigang
#+EMAIL: guweigang@outlook.com
#+DATE: 2011-02-21 Mon
#+URI: /blog/2011/02/21/how-to-get-an-array-in-php-before-a-specified-element-or-elements-after-a/
#+KEYWORDS: 
#+TAGS: array, next, php, pre
#+LANGUAGE: zh_CN
#+OPTIONS: H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 

方法一：用循环


#+BEGIN_EXAMPLE
    
function getNext(&$array, $curr_key)
{
    $next = 0;
    reset($array);

    do
    {
        $tmp_key = key($array);
        $res = next($array);
    } while ( ($tmp_key != $curr_key) && $res );

    if( $res )
    {
        $next = key($array);
    }

    return $next;
}

function getPrev(&$array, $curr_key)
{
    end($array);
    $prev = key($array);

    do
    {
        $tmp_key = key($array);
        $res = prev($array);
    } while ( ($tmp_key != $curr_key) && $res );

    if( $res )
    {
        $prev = key($array);
    }

    return $prev;
}

#+END_EXAMPLE


方法二：用Iterator，不过要先得到position


#+BEGIN_EXAMPLE
    
// 默认查找键为key元素的后一个元素
function get_element($key, $arr, $who='next')
{
    //查找键为$key元素的位置
    $offset = array_search($key, array_keys($arr));
    if(FALSE == $offset || NULL == $offset) { return ;}

    //查找哪个元素，前一个或后一个？
    if ('prev' == $who) {
        $arr = array_reverse($arr);
    } else if ('next' == $who) {

    } else {
        throw new Exception("错误的参数");
    }

    $iterator = new ArrayIterator($arr);
    $iterator->seek($offset);
    $iterator->next();

    //返回数组当前指针指向元素的键值数组
    return array($iterator->key(), $iterator->current());
}

$arr = array('foo' => 10, 'bar' => 45, 'baz' => 23);
$key ='bar';

print_r(get_element($key, $arr));


#+END_EXAMPLE



方法三：[[http://www.thin5.com/][老风]]给的方法

我按照老风的意思写的：


#+BEGIN_EXAMPLE
    
function get_element($key, $array, $who='next') {
 //先获取key 的位置
  $arr_keys = array_keys($array);
    $arr_keys_flip = array_flip($arr_keys);

    if (array_key_exists($key, $arr_keys_flip)) {
        $location = $arr_keys_flip[$key];//返回KEY的位置
    } else {
        throw new Exception("数组中不存在此键");
    }

   $arr_values = array_values($array);

    //查找哪个元素，前一个或后一个？
    if ('prev' == $who) {
        $pos = $location-1;
    } else if ('next' == $who) {
        $pos = $location+1;
    } else {
        throw new Exception("错误的参数");
    }

 return array($arr_keys[$pos], $arr_values[$pos]);
}

#+END_EXAMPLE



老风觉得太长，又优化了一遍


#+BEGIN_EXAMPLE
    
function get_element($key, $array, $who='next'){
  $arr_keys = array_keys($array);
   $arr_keys_flip = array_flip($arr_keys);
   $location = (array_key_exists($key,$arr_keys_flip))?$arr_keys_flip[$key]:die('数组中不存在此键');
 $arr_values = array_values($array);
   $info = array('prev'=>$location-1,'next'=>$location+1);
   $pos = (array_key_exists($who,$info))?$info[$who]:die('错误的参数');
   return array($arr_keys[$pos], $arr_values[$pos]);
}

#+END_EXAMPLE



经过效率测试，方法二的效率最高，不过仍然存在瓶颈，那就是array\_keys函数，因此如果此处使用foreach取得location将会大大提高效率：


#+BEGIN_EXAMPLE
    
function get_element($key, $arr, $who='next')
{
    //查找键为$key元素的位置
    $offset = 0;
    foreach ($arr as $_k => $_v) {
        if($_k == $key) break;++$offset;
    }

    //查找哪个元素，前一个或后一个？
    if ('prev' == $who) {
        $arr = array_reverse($arr);
    } else if ('next' == $who) {

    } else {
        throw new Exception("错误的参数");
    }

    $iterator = new ArrayIterator($arr);
    $iterator->seek($offset);
    $iterator->next();

    //返回数组当前指针指向元素的键值数组
    return array($iterator->key(), $iterator->current());
}

#+END_EXAMPLE



